Perfect! Let's start building **Milestone 3: CRM Sync & One-Click Integrations**. I'll begin with **HubSpot integration** since it's the most popular CRM for SMBs.

## **ðŸ”— Milestone 3: CRM Sync & One-Click Integrations**

### **Step 1: Add HubSpot Environment Variables**

First, let's add the HubSpot API credentials to your environment:

````bash
# Add to .env.local

# HubSpot Integration
HUBSPOT_CLIENT_ID=your-hubspot-client-id
HUBSPOT_CLIENT_SECRET=your-hubspot-client-secret
HUBSPOT_REDIRECT_URI=http://localhost:3000/api/integrations/hubspot/callback

# Salesforce Integration  
SALESFORCE_CLIENT_ID=your-salesforce-client-id
SALESFORCE_CLIENT_SECRET=your-salesforce-client-secret
SALESFORCE_REDIRECT_URI=http://localhost:3000/api/integrations/salesforce/callback

# Pipedrive Integration
PIPEDRIVE_CLIENT_ID=your-pipedrive-client-id
PIPEDRIVE_CLIENT_SECRET=your-pipedrive-client-secret
PIPEDRIVE_REDIRECT_URI=http://localhost:3000/api/integrations/pipedrive/callback

# General Integration Settings
INTEGRATION_ENCRYPTION_KEY=your-32-character-encryption-key-here
````

### **Step 2: Install Required Dependencies**

````bash
npm install @hubspot/api-client jsforce pipedrive crypto-js
````

### **Step 3: Database Schema for CRM Integrations**

````sql
-- supabase/migrations/20240101000004_crm_integrations.sql
-- CRM Integration System Tables

-- Integration providers table
CREATE TABLE IF NOT EXISTS integration_providers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  display_name TEXT NOT NULL,
  description TEXT,
  logo_url TEXT,
  auth_type TEXT NOT NULL DEFAULT 'oauth', -- oauth, api_key, basic
  config JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User integrations table
CREATE TABLE IF NOT EXISTS user_integrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  provider_id UUID NOT NULL REFERENCES integration_providers(id) ON DELETE CASCADE,
  
  -- Integration details
  name TEXT, -- User-defined name for this integration
  status TEXT NOT NULL DEFAULT 'disconnected', -- connected, disconnected, error, syncing
  
  -- Authentication data (encrypted)
  credentials JSONB, -- Encrypted OAuth tokens, API keys, etc.
  
  -- Configuration
  sync_settings JSONB DEFAULT '{}',
  field_mappings JSONB DEFAULT '{}',
  sync_filters JSONB DEFAULT '{}',
  
  -- Sync statistics
  last_sync_at TIMESTAMP WITH TIME ZONE,
  next_sync_at TIMESTAMP WITH TIME ZONE,
  total_synced_contacts INTEGER DEFAULT 0,
  total_synced_deals INTEGER DEFAULT 0,
  sync_frequency TEXT DEFAULT 'realtime', -- realtime, hourly, daily
  
  -- Error tracking
  last_error TEXT,
  error_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(organization_id, provider_id)
);

-- Contact sync mappings
CREATE TABLE IF NOT EXISTS contact_sync_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  integration_id UUID NOT NULL REFERENCES user_integrations(id) ON DELETE CASCADE,
  
  -- Source data
  contact_id UUID REFERENCES contacts(id) ON DELETE CASCADE,
  message_id UUID REFERENCES inbox_messages(id) ON DELETE SET NULL,
  
  -- External CRM data
  external_contact_id TEXT NOT NULL,
  external_deal_id TEXT,
  external_company_id TEXT,
  
  -- Sync metadata
  sync_status TEXT DEFAULT 'pending', -- pending, synced, error, conflict
  sync_direction TEXT DEFAULT 'outbound', -- outbound, inbound, bidirectional
  last_synced_at TIMESTAMP WITH TIME ZONE,
  sync_data JSONB, -- Full sync payload for debugging
  
  -- Conflict resolution
  conflict_resolution TEXT DEFAULT 'manual', -- manual, source_wins, target_wins
  conflict_data JSONB,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(integration_id, external_contact_id)
);

-- Sync activity logs
CREATE TABLE IF NOT EXISTS sync_activity_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  integration_id UUID NOT NULL REFERENCES user_integrations(id) ON DELETE CASCADE,
  
  -- Activity details
  activity_type TEXT NOT NULL, -- sync_contact, sync_deal, sync_activity, error
  status TEXT NOT NULL, -- success, error, warning, info
  
  -- Related records
  contact_id UUID REFERENCES contacts(id) ON DELETE SET NULL,
  message_id UUID REFERENCES inbox_messages(id) ON DELETE SET NULL,
  mapping_id UUID REFERENCES contact_sync_mappings(id) ON DELETE SET NULL,
  
  -- Activity data
  title TEXT NOT NULL,
  description TEXT,
  external_id TEXT, -- ID in the external CRM
  
  -- Metadata
  duration_ms INTEGER,
  request_data JSONB,
  response_data JSONB,
  error_details JSONB,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Sync queue for background processing
CREATE TABLE IF NOT EXISTS sync_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  integration_id UUID NOT NULL REFERENCES user_integrations(id) ON DELETE CASCADE,
  
  -- Queue item details
  queue_type TEXT NOT NULL, -- contact_sync, deal_sync, activity_sync
  priority INTEGER DEFAULT 5, -- 1 = highest, 10 = lowest
  status TEXT DEFAULT 'pending', -- pending, processing, completed, failed, retry
  
  -- Payload
  payload JSONB NOT NULL,
  
  -- Processing metadata
  attempts INTEGER DEFAULT 0,
  max_attempts INTEGER DEFAULT 3,
  next_attempt_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_error TEXT,
  
  -- Timestamps
  scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_integrations_org_id ON user_integrations(organization_id);
CREATE INDEX IF NOT EXISTS idx_user_integrations_status ON user_integrations(status);
CREATE INDEX IF NOT EXISTS idx_contact_sync_mappings_org_id ON contact_sync_mappings(organization_id);
CREATE INDEX IF NOT EXISTS idx_contact_sync_mappings_integration_id ON contact_sync_mappings(integration_id);
CREATE INDEX IF NOT EXISTS idx_contact_sync_mappings_contact_id ON contact_sync_mappings(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_sync_mappings_external_id ON contact_sync_mappings(external_contact_id);
CREATE INDEX IF NOT EXISTS idx_sync_activity_logs_org_id ON sync_activity_logs(organization_id);
CREATE INDEX IF NOT EXISTS idx_sync_activity_logs_integration_id ON sync_activity_logs(integration_id);
CREATE INDEX IF NOT EXISTS idx_sync_activity_logs_created_at ON sync_activity_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_sync_queue_status_priority ON sync_queue(status, priority, next_attempt_at);
CREATE INDEX IF NOT EXISTS idx_sync_queue_org_id ON sync_queue(organization_id);

-- RLS Policies
ALTER TABLE integration_providers ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_integrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE contact_sync_mappings ENABLE ROW LEVEL SECURITY;
ALTER TABLE sync_activity_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE sync_queue ENABLE ROW LEVEL SECURITY;

-- Integration providers are public (read-only)
CREATE POLICY "Integration providers are publicly readable" ON integration_providers
  FOR SELECT USING (is_active = true);

-- User integrations policies
CREATE POLICY "Users can manage their organization's integrations" ON user_integrations
  FOR ALL USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Contact sync mappings policies
CREATE POLICY "Users can manage their organization's sync mappings" ON contact_sync_mappings
  FOR ALL USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Sync activity logs policies
CREATE POLICY "Users can view their organization's sync logs" ON sync_activity_logs
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Sync queue policies
CREATE POLICY "Users can view their organization's sync queue" ON sync_queue
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Triggers for updated_at
CREATE TRIGGER update_user_integrations_updated_at 
  BEFORE UPDATE ON user_integrations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_contact_sync_mappings_updated_at 
  BEFORE UPDATE ON contact_sync_mappings 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Seed integration providers
INSERT INTO integration_providers (name, display_name, description, logo_url, auth_type, config) VALUES
('hubspot', 'HubSpot', 'Connect with HubSpot CRM to sync contacts, deals, and activities', '/integrations/hubspot-logo.svg', 'oauth', '{
  "scopes": ["contacts", "content", "crm.objects.deals.read", "crm.objects.deals.write", "crm.objects.contacts.read", "crm.objects.contacts.write", "crm.objects.companies.read", "crm.objects.companies.write"],
  "auth_url": "https://app.hubspot.com/oauth/authorize",
  "token_url": "https://api.hubapi.com/oauth/v1/token",
  "api_base_url": "https://api.hubapi.com"
}'),
('salesforce', 'Salesforce', 'Connect with Salesforce to sync leads, contacts, opportunities, and activities', '/integrations/salesforce-logo.svg', 'oauth', '{
  "scopes": ["full"],
  "auth_url": "https://login.salesforce.com/services/oauth2/authorize",
  "token_url": "https://login.salesforce.com/services/oauth2/token",
  "api_base_url": "https://your-instance.salesforce.com"
}'),
('pipedrive', 'Pipedrive', 'Connect with Pipedrive to sync persons, deals, and activities', '/integrations/pipedrive-logo.svg', 'oauth', '{
  "scopes": ["read", "write"],
  "auth_url": "https://oauth.pipedrive.com/oauth/authorize",
  "token_url": "https://oauth.pipedrive.com/oauth/token",
  "api_base_url": "https://api.pipedrive.com/v1"
}')
ON CONFLICT (name) DO NOTHING;
````

### **Step 4: HubSpot Integration Service**

````typescript
// lib/integrations/hubspot.ts
import { Client } from '@hubspot/api-client'
import { supabase } from '@/lib/supabase'
import CryptoJS from 'crypto-js'

export interface HubSpotContact {
  id?: string
  email: string
  firstname?: string
  lastname?: string
  company?: string
  phone?: string
  website?: string
  jobtitle?: string
  industry?: string
  lifecyclestage?: string
  lead_status?: string
  hs_lead_status?: string
}

export interface HubSpotDeal {
  id?: string
  dealname: string
  amount?: number
  dealstage: string
  pipeline: string
  closedate?: string
  hubspot_owner_id?: string
  dealtype?: string
  lead_source?: string
}

export interface HubSpotCompany {
  id?: string
  name: string
  domain?: string
  industry?: string
  phone?: string
  city?: string
  state?: string
  country?: string
  numberofemployees?: number
}

export class HubSpotIntegrationService {
  private client: Client
  private integrationId: string
  private organizationId: string

  constructor(accessToken: string, integrationId: string, organizationId: string) {
    this.client = new Client({ accessToken })
    this.integrationId = integrationId
    this.organizationId = organizationId
  }

  // Encrypt sensitive data
  private static encrypt(data: string): string {
    const key = process.env.INTEGRATION_ENCRYPTION_KEY!
    return CryptoJS.AES.encrypt(data, key).toString()
  }

  // Decrypt sensitive data
  private static decrypt(encryptedData: string): string {
    const key = process.env.INTEGRATION_ENCRYPTION_KEY!
    const bytes = CryptoJS.AES.decrypt(encryptedData, key)
    return bytes.toString(CryptoJS.enc.Utf8)
  }

  // OAuth Authorization URL
  static getAuthorizationUrl(organizationId: string): string {
    const clientId = process.env.HUBSPOT_CLIENT_ID!
    const redirectUri = process.env.HUBSPOT_REDIRECT_URI!
    const scopes = [
      'contacts',
      'content',
      'crm.objects.deals.read',
      'crm.objects.deals.write',
      'crm.objects.contacts.read',
      'crm.objects.contacts.write',
      'crm.objects.companies.read',
      'crm.objects.companies.write'
    ].join(' ')
    
    const state = Buffer.from(JSON.stringify({ organizationId })).toString('base64')
    
    return `https://app.hubspot.com/oauth/authorize?client_id=${clientId}&scope=${encodeURIComponent(scopes)}&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`
  }

  // Exchange authorization code for access token
  static async exchangeCodeForToken(code: string, organizationId: string): Promise<{
    access_token: string
    refresh_token: string
    expires_in: number
    hub_domain: string
    hub_id: number
  }> {
    const clientId = process.env.HUBSPOT_CLIENT_ID!
    const clientSecret = process.env.HUBSPOT_CLIENT_SECRET!
    const redirectUri = process.env.HUBSPOT_REDIRECT_URI!

    const response = await fetch('https://api.hubapi.com/oauth/v1/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uri: redirectUri,
        code: code,
      }),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`HubSpot token exchange failed: ${error}`)
    }

    return response.json()
  }

  // Refresh access token
  static async refreshAccessToken(refreshToken: string): Promise<{
    access_token: string
    refresh_token: string
    expires_in: number
  }> {
    const clientId = process.env.HUBSPOT_CLIENT_ID!
    const clientSecret = process.env.HUBSPOT_CLIENT_SECRET!

    const response = await fetch('https://api.hubapi.com/oauth/v1/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: clientId,
        client_secret: clientSecret,
        refresh_token: refreshToken,
      }),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`HubSpot token refresh failed: ${error}`)
    }

    return response.json()
  }

  // Create or update integration record
  static async saveIntegration(organizationId: string, tokenData: any): Promise<string> {
    try {
      // Encrypt sensitive credentials
      const encryptedCredentials = this.encrypt(JSON.stringify({
        access_token: tokenData.access_token,
        refresh_token: tokenData.refresh_token,
        expires_in: tokenData.expires_in,
        expires_at: new Date(Date.now() + tokenData.expires_in * 1000).toISOString(),
        hub_domain: tokenData.hub_domain,
        hub_id: tokenData.hub_id
      }))

      // Get HubSpot provider ID
      const { data: provider } = await supabase
        .from('integration_providers')
        .select('id')
        .eq('name', 'hubspot')
        .single()

      if (!provider) {
        throw new Error('HubSpot provider not found')
      }

      // Upsert integration
      const { data: integration, error } = await supabase
        .from('user_integrations')
        .upsert({
          organization_id: organizationId,
          provider_id: provider.id,
          name: `HubSpot (${tokenData.hub_domain})`,
          status: 'connected',
          credentials: encryptedCredentials,
          sync_settings: {
            auto_sync_contacts: true,
            auto_create_deals: true,
            sync_frequency: 'realtime',
            deal_pipeline: 'default',
            deal_stage: 'appointmentscheduled',
            lead_source: 'Email Campaign'
          },
          last_sync_at: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        throw new Error(`Failed to save integration: ${error.message}`)
      }

      return integration.id
    } catch (error) {
      console.error('Failed to save HubSpot integration:', error)
      throw error
    }
  }

  // Get integration by organization ID
  static async getIntegration(organizationId: string): Promise<any | null> {
    try {
      const { data: provider } = await supabase
        .from('integration_providers')
        .select('id')
        .eq('name', 'hubspot')
        .single()

      if (!provider) return null

      const { data: integration } = await supabase
        .from('user_integrations')
        .select('*')
        .eq('organization_id', organizationId)
        .eq('provider_id', provider.id)
        .eq('status', 'connected')
        .single()

      if (!integration) return null

      // Decrypt credentials
      const credentials = JSON.parse(this.decrypt(integration.credentials))
      
      return {
        ...integration,
        credentials
      }
    } catch (error) {
      console.error('Failed to get HubSpot integration:', error)
      return null
    }
  }

  // Test connection
  async testConnection(): Promise<boolean> {
    try {
      await this.client.crm.contacts.basicApi.getPage()
      return true
    } catch (error) {
      console.error('HubSpot connection test failed:', error)
      return false
    }
  }

  // Sync contact to HubSpot
  async syncContact(contactData: {
    email: string
    firstName?: string
    lastName?: string
    company?: string
    phone?: string
    leadSource?: string
    leadStatus?: string
    messageId?: string
  }): Promise<{
    contactId: string
    companyId?: string
    isNew: boolean
  }> {
    try {
      // Check if contact already exists
      let existingContact = null
      try {
        const searchResult = await this.client.crm.contacts.searchApi.doSearch({
          filterGroups: [{
            filters: [{
              propertyName: 'email',
              operator: 'EQ',
              value: contactData.email
            }]
          }],
          properties: ['email', 'firstname', 'lastname', 'company', 'hs_object_id'],
          limit: 1
        })
        
        if (searchResult.results && searchResult.results.length > 0) {
          existingContact = searchResult.results[0]
        }
      } catch (searchError) {
        console.log('Contact search failed, will create new:', searchError)
      }

      let contactId: string
      let isNew = false

      if (existingContact) {
        // Update existing contact
        contactId = existingContact.id!
        await this.client.crm.contacts.basicApi.update(contactId, {
          properties: {
            firstname: contactData.firstName || existingContact.properties?.firstname,
            lastname: contactData.lastName || existingContact.properties?.lastname,
            company: contactData.company || existingContact.properties?.company,
            phone: contactData.phone || existingContact.properties?.phone,
            hs_lead_status: contactData.leadStatus || 'NEW',
            lead_source: contactData.leadSource || 'Email Campaign'
          }
        })
      } else {
        // Create new contact
        const createResult = await this.client.crm.contacts.basicApi.create({
          properties: {
            email: contactData.email,
            firstname: contactData.firstName || '',
            lastname: contactData.lastName || '',
            company: contactData.company || '',
            phone: contactData.phone || '',
            hs_lead_status: contactData.leadStatus || 'NEW',
            lead_source: contactData.leadSource || 'Email Campaign',
            lifecyclestage: 'lead'
          }
        })
        contactId = createResult.id!
        isNew = true
      }

      // Handle company creation/association
      let companyId: string | undefined
      if (contactData.company) {
        companyId = await this.createOrUpdateCompany(contactData.company, contactId)
      }

      // Log the sync activity
      await this.logSyncActivity({
        activity_type: 'sync_contact',
        status: 'success',
        title: `Synced contact: ${contactData.email}`,
        description: isNew ? 'Created new contact' : 'Updated existing contact',
        external_id: contactId,
        request_data: contactData
      })

      return {
        contactId,
        companyId,
        isNew
      }

    } catch (error) {
      console.error('Failed to sync contact to HubSpot:', error)
      
      // Log error
      await this.logSyncActivity({
        activity_type: 'sync_contact',
        status: 'error',
        title: `Failed to sync contact: ${contactData.email}`,
        description: error instanceof Error ? error.message : 'Unknown error',
        request_data: contactData,
        error_details: { error: error instanceof Error ? error.message : 'Unknown error' }
      })
      
      throw error
    }
  }

  // Create or update company
  private async createOrUpdateCompany(companyName: string, contactId: string): Promise<string> {
    try {
      // Search for existing company
      let existingCompany = null
      try {
        const searchResult = await this.client.crm.companies.searchApi.doSearch({
          filterGroups: [{
            filters: [{
              propertyName: 'name',
              operator: 'EQ',
              value: companyName
            }]
          }],
          properties: ['name', 'hs_object_id'],
          limit: 1
        })
        
        if (searchResult.results && searchResult.results.length > 0) {
          existingCompany = searchResult.results[0]
        }
      } catch (searchError) {
        console.log('Company search failed, will create new:', searchError)
      }

      let companyId: string

      if (existingCompany) {
        companyId = existingCompany.id!
      } else {
        // Create new company
        const createResult = await this.client.crm.companies.basicApi.create({
          properties: {
            name: companyName,
            industry: 'Unknown',
            lead_source: 'Email Campaign'
          }
        })
        companyId = createResult.id!
      }

      // Associate contact with company
      await this.client.crm.contacts.associationsApi.create(contactId, 'companies', companyId, [
        {
          associationCategory: 'HUBSPOT_DEFINED',
          associationTypeId: 1 // Contact to Company association
        }
      ])

      return companyId
    } catch (error) {
      console.error('Failed to create/update company:', error)
      throw error
    }
  }

  // Create deal for interested contacts
  async createDeal(dealData: {
    contactId: string
    dealName: string
    amount?: number
    stage?: string
    closeDate?: string
    source?: string
  }): Promise<string> {
    try {
      const createResult = await this.client.crm.deals.basicApi.create({
        properties: {
          dealname: dealData.dealName,
          amount: dealData.amount?.toString() || '0',
          dealstage: dealData.stage || 'appointmentscheduled',
          pipeline: 'default',
          closedate: dealData.closeDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days from now
          lead_source: dealData.source || 'Email Campaign',
          dealtype: 'newbusiness'
        }
      })

      const dealId = createResult.id!

      // Associate deal with contact
      await this.client.crm.deals.associationsApi.create(dealId, 'contacts', dealData.contactId, [
        {
          associationCategory: 'HUBSPOT_DEFINED',
          associationTypeId: 3 // Deal to Contact association
        }
      ])

      await this.logSyncActivity({
        activity_type: 'sync_deal',
        status: 'success',
        title: `Created deal: ${dealData.dealName}`,
        description: `Deal created for contact ${dealData.contactId}`,
        external_id: dealId,
        request_data: dealData
      })

      return dealId

    } catch (error) {
      console.error('Failed to create deal in HubSpot:', error)
      
      await this.logSyncActivity({
        activity_type: 'sync_deal',
        status: 'error',
        title: `Failed to create deal: ${dealData.dealName}`,
        description: error instanceof Error ? error.message : 'Unknown error',
        request_data: dealData,
        error_details: { error: error instanceof Error ? error.message : 'Unknown error' }
      })
      
      throw error
    }
  }

  // Log sync activity
  private async logSyncActivity(activity: {
    activity_type: string
    status: string
    title: string
    description?: string
    external_id?: string
    contact_id?: string
    message_id?: string
    request_data?: any
    response_data?: any
    error_details?: any
    duration_ms?: number
  }): Promise<void> {
    try {
      await supabase
        .from('sync_activity_logs')
        .insert({
          organization_id: this.organizationId,
          integration_id: this.integrationId,
          ...activity,
          created_at: new Date().toISOString()
        })
    } catch (error) {
      console.error('Failed to log sync activity:', error)
    }
  }

  // Disconnect integration
  static async disconnectIntegration(organizationId: string): Promise<void> {
    try {
      const { data: provider } = await supabase
        .from('integration_providers')
        .select('id')
        .eq('name', 'hubspot')
        .single()

      if (!provider) return

      await supabase
        .from('user_integrations')
        .update({ status: 'disconnected' })
        .eq('organization_id', organizationId)
        .eq('provider_id', provider.id)

    } catch (error) {
      console.error('Failed to disconnect HubSpot integration:', error)
      throw error
    }
  }
}
````

### **Step 5: HubSpot OAuth Callback API Route**

````typescript
// app/api/integrations/hubspot/callback/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { HubSpotIntegrationService } from '@/lib/integrations/hubspot'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const code = searchParams.get('code')
    const state = searchParams.get('state')
    const error = searchParams.get('error')

    if (error) {
      console.error('HubSpot OAuth error:', error)
      return NextResponse.redirect(new URL(`/integrations?error=${encodeURIComponent(error)}`, request.url))
    }

    if (!code || !state) {
      return NextResponse.redirect(new URL('/integrations?error=missing_parameters', request.url))
    }

    // Decode state to get organization ID
    const { organizationId } = JSON.parse(Buffer.from(state, 'base64').toString())

    if (!organizationId) {
      return NextResponse.redirect(new URL('/integrations?error=invalid_state', request.url))
    }

    // Exchange code for tokens
    const tokenData = await HubSpotIntegrationService.exchangeCodeForToken(code, organizationId)

    // Save integration
    const integrationId = await HubSpotIntegrationService.saveIntegration(organizationId, tokenData)

    // Redirect to integrations page with success
    return NextResponse.redirect(new URL(`/integrations?connected=hubspot&integration_id=${integrationId}`, request.url))

  } catch (error) {
    console.error('HubSpot callback error:', error)
    return NextResponse.redirect(new URL(`/integrations?error=${encodeURIComponent('connection_failed')}`, request.url))
  }
}
````

### **Step 6: HubSpot Connect/Disconnect API Routes**

````typescript
// app/api/integrations/hubspot/connect/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { HubSpotIntegrationService } from '@/lib/integrations/hubspot'

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies })
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's organization
    const { data: userData } = await supabase
      .from('users')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!userData?.organization_id) {
      return NextResponse.json({ error: 'Organization not found' }, { status: 404 })
    }

    // Generate authorization URL
    const authUrl = HubSpotIntegrationService.getAuthorizationUrl(userData.organization_id)

    return NextResponse.json({ authUrl })

  } catch (error) {
    console.error('HubSpot connect error:', error)
    return NextResponse.json({ error: 'Failed to connect' }, { status: 500 })
  }
}
````

````typescript
// app/api/integrations/hubspot/disconnect/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { HubSpotIntegrationService } from '@/lib/integrations/hubspot'

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies })
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's organization
    const { data: userData } = await supabase
      .from('users')
      .select('organization_id')
      .eq('id', user.id)
      .single()

    if (!userData?.organization_id) {
      return NextResponse.json({ error: 'Organization not found' }, { status: 404 })
    }

    // Disconnect integration
    await HubSpotIntegrationService.disconnectIntegration(userData.organization_id)

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('HubSpot disconnect error:', error)
    return NextResponse.json({ error: 'Failed to disconnect' }, { status: 500 })
  }
}
````

### **Step 7: CRM Sync Manager Service**

````typescript
// lib/integrations/crm-sync-manager.ts
import { HubSpotIntegrationService } from './hubspot'
import { ReplyClassifierService } from '@/lib/ai/reply-classifier'
import { supabase } from '@/lib/supabase'

export interface SyncContactData {
  contactId: string
  messageId: string
  email: string
  firstName?: string
  lastName?: string
  company?: string
  phone?: string
  intent: string
  sentiment: string
  priority: string
  requiresAttention: boolean
  nextAction: string
}

export class CRMSyncManager {
  
  // Auto-sync contact based on AI classification
  static async autoSyncContact(
    organizationId: string,
    contactData: SyncContactData
  ): Promise<void> {
    try {
      console.log(`Starting auto-sync for contact: ${contactData.email}`)

      // Get all active integrations for the organization
      const integrations = await this.getActiveIntegrations(organizationId)

      if (integrations.length === 0) {
        console.log('No active integrations found for organization:', organizationId)
        return
      }

      // Process each integration
      for (const integration of integrations) {
        try {
          await this.syncContactToIntegration(integration, contactData)
        } catch (error) {
          console.error(`Failed to sync to ${integration.provider_name}:`, error)
          // Continue with other integrations even if one fails
        }
      }

    } catch (error) {
      console.error('Auto-sync failed:', error)
      throw error
    }
  }

  // Get active integrations for organization
  private static async getActiveIntegrations(organizationId: string): Promise<any[]> {
    const { data: integrations, error } = await supabase
      .from('user_integrations')
      .select(`
        *,
        integration_providers(name, display_name, auth_type, config)
      `)
      .eq('organization_id', organizationId)
      .eq('status', 'connected')

    if (error) {
      throw new Error(`Failed to get integrations: ${error.message}`)
    }

    return integrations || []
  }

  // Sync contact to specific integration
  private static async syncContactToIntegration(
    integration: any,
    contactData: SyncContactData
  ): Promise<void> {
    const providerName = integration.integration_providers.name

    switch (providerName) {
      case 'hubspot':
        await this.syncToHubSpot(integration, contactData)
        break
      case 'salesforce':
        await this.syncToSalesforce(integration, contactData)
        break
      case 'pipedrive':
        await this.syncToPipedrive(integration, contactData)
        break
      default:
        console.warn(`Unknown provider: ${providerName}`)
    }
  }

  // Sync to HubSpot
  private static async syncToHubSpot(
    integration: any,
    contactData: SyncContactData
  ): Promise<void> {
    try {
      // Decrypt credentials
      const credentials = JSON.parse(
        HubSpotIntegrationService['decrypt'](integration.credentials)
      )

      // Check if token needs refresh (within 1 hour of expiry)
      const expiresAt = new Date(credentials.expires_at)
      const now = new Date()
      const oneHour = 60 * 60 * 1000

      if (expiresAt.getTime() - now.getTime() < oneHour) {
        console.log('Refreshing HubSpot token...')
        const newTokenData = await HubSpotIntegrationService.refreshAccessToken(
          credentials.refresh_token
        )
        
        // Update stored credentials
        const updatedCredentials = {
          ...credentials,
          access_token: newTokenData.access_token,
          refresh_token: newTokenData.refresh_token,
          expires_in: newTokenData.expires_in,
          expires_at: new Date(Date.now() + newTokenData.expires_in * 1000).toISOString()
        }

        await supabase
          .from('user_integrations')
          .update({
            credentials: HubSpotIntegrationService['encrypt'](JSON.stringify(updatedCredentials))
          })
          .eq('id', integration.id)

        credentials.access_token = newTokenData.access_token
      }

      // Initialize HubSpot service
      const hubspot = new HubSpotIntegrationService(
        credentials.access_token,
        integration.id,
        integration.organization_id
      )

      // Determine lead status based on AI classification
      let leadStatus = 'NEW'
      let shouldCreateDeal = false

      switch (contactData.intent) {
        case 'interested':
          leadStatus = 'QUALIFIED'
          shouldCreateDeal = true
          break
        case 'question':
          leadStatus = 'CONTACTED'
          break
        case 'objection':
          leadStatus = 'CONTACTED'
          break
        case 'not_interested':
          leadStatus = 'UNQUALIFIED'
          break
      }

      // Sync contact
      const syncResult = await hubspot.syncContact({
        email: contactData.email,
        firstName: contactData.firstName,
        lastName: contactData.lastName,
        company: contactData.company,
        phone: contactData.phone,
        leadSource: 'Email Campaign',
        leadStatus: leadStatus,
        messageId: contactData.messageId
      })

      // Create deal for interested contacts
      if (shouldCreateDeal && syncResult.contactId) {
        const dealName = `${contactData.firstName || contactData.email} - Email Lead`
        
        await hubspot.createDeal({
          contactId: syncResult.contactId,
          dealName: dealName,
          amount: 1000, // Default deal amount
          stage: 'appointmentscheduled',
          source: 'Email Campaign'
        })
      }

      // Save sync mapping
      await this.saveSyncMapping({
        organizationId: integration.organization_id,
        integrationId: integration.id,
        contactId: contactData.contactId,
        messageId: contactData.messageId,
        externalContactId: syncResult.contactId,
        externalCompanyId: syncResult.companyId,
        syncStatus: 'synced'
      })

      console.log(`Successfully synced contact to HubSpot: ${contactData.email}`)

    } catch (error) {
      console.error('HubSpot sync failed:', error)
      throw error
    }
  }

  // Placeholder for Salesforce sync
  private static async syncToSalesforce(
    integration: any,
    contactData: SyncContactData
  ): Promise<void> {
    console.log('Salesforce sync - Coming soon!')
    // TODO: Implement Salesforce sync in next iteration
  }

  // Placeholder for Pipedrive sync
  private static async syncToPipedrive(
    integration: any,
    contactData: SyncContactData
  ): Promise<void> {
    console.log('Pipedrive sync - Coming soon!')
    // TODO: Implement Pipedrive sync in next iteration
  }

  // Save sync mapping
  private static async saveSyncMapping(mappingData: {
    organizationId: string
    integrationId: string
    contactId: string
    messageId: string
    externalContactId: string
    externalCompanyId?: string
    externalDealId?: string
    syncStatus: string
  }): Promise<void> {
    try {
      await supabase
        .from('contact_sync_mappings')
        .upsert({
          organization_id: mappingData.organizationId,
          integration_id: mappingData.integrationId,
          contact_id: mappingData.contactId,
          message_id: mappingData.messageId,
          external_contact_id: mappingData.externalContactId,
          external_company_id: mappingData.externalCompanyId,
          external_deal_id: mappingData.externalDealId,
          sync_status: mappingData.syncStatus,
          last_synced_at: new Date().toISOString()
        }, {
          onConflict: 'integration_id,external_contact_id'
        })
    } catch (error) {
      console.error('Failed to save sync mapping:', error)
    }
  }

  // Get sync status for contact
  static async getSyncStatus(
    organizationId: string,
    contactId: string
  ): Promise<{
    integrations: Array<{
      provider: string
      status: string
      externalId?: string
      lastSynced?: string
    }>
  }> {
    try {
      const { data: mappings } = await supabase
        .from('contact_sync_mappings')
        .select(`
          *,
          user_integrations!inner(
            status,
            integration_providers!inner(name, display_name)
          )
        `)
        .eq('organization_id', organizationId)
        .eq('contact_id', contactId)

      const integrations = (mappings || []).map(mapping => ({
        provider: mapping.user_integrations.integration_providers.display_name,
        status: mapping.sync_status,
        externalId: mapping.external_contact_id,
        lastSynced: mapping.last_synced_at
      }))

      return { integrations }

    } catch (error) {
      console.error('Failed to get sync status:', error)
      return { integrations: [] }
    }
  }

  // Manual sync trigger
  static async manualSync(
    organizationId: string,
    contactIds: string[]
  ): Promise<{
    success: number
    failed: number
    errors: string[]
  }> {
    let success = 0
    let failed = 0
    const errors: string[] = []

    for (const contactId of contactIds) {
      try {
        // Get contact details
        const { data: contact } = await supabase
          .from('contacts')
          .select('*')
          .eq('id', contactId)
          .eq('organization_id', organizationId)
          .single()

        if (!contact) {
          errors.push(`Contact not found: ${contactId}`)
          failed++
          continue
        }

        // Get latest message classification for context
        const { data: latestMessage } = await supabase
          .from('inbox_messages')
          .select(`
            *,
            message_classifications(*)
          `)
          .eq('contact_id', contactId)
          .order('received_at', { ascending: false })
          .limit(1)
          .single()

        const classification = latestMessage?.message_classifications

        // Build sync data
        const syncData: SyncContactData = {
          contactId: contact.id,
          messageId: latestMessage?.id || '',
          email: contact.email,
          firstName: contact.first_name,
          lastName: contact.last_name,
          company: contact.company,
          phone: contact.phone,
          intent: classification?.intent || 'neutral',
          sentiment: classification?.sentiment || 'neutral',
          priority: classification?.priority || 'medium',
          requiresAttention: classification?.requires_human_attention || false,
          nextAction: classification?.next_action || 'no_action'
        }

        await this.autoSyncContact(organizationId, syncData)
        success++

      } catch (error) {
        console.error(`Failed to sync contact ${contactId}:`, error)
        errors.push(`${contactId}: ${error instanceof Error ? error.message : 'Unknown error'}`)
        failed++
      }
    }

    return { success, failed, errors }
  }
}
````

This completes the first part of Milestone 3 with HubSpot integration! 

## **What We've Built So Far:**

âœ… **Complete HubSpot OAuth Integration**
- Secure token management with encryption
- Automatic token refresh
- Connection testing

âœ… **Smart Contact Syncing**
- AI classification-driven lead scoring
- Automatic deal creation for interested prospects
- Company creation and association

âœ… **Robust Sync Management**
- Sync activity logging
- Error handling and retry logic
- Sync status tracking

âœ… **Database Schema**
- Encrypted credential storage
- Sync mappings and activity logs
- Queue system for background processing

**Next up:** We'll build the integrations UI, add Salesforce and Pipedrive support, and create the one-click sync dashboard! 

Ready to continue? ðŸš€