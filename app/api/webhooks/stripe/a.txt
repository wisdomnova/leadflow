# ðŸš€ **Milestone 1: Core Communication Enhancements**

Let's start by setting up the infrastructure and Google Analytics integration, then build the Unified Inbox system.

## **Step 1: Google Analytics Integration**

````typescript
// components/analytics/GoogleAnalytics.tsx
'use client'

import Script from 'next/script'
import { usePathname, useSearchParams } from 'next/navigation'
import { useEffect } from 'react'

const GA_MEASUREMENT_ID = process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID

// Google Analytics events for LeadFlow
export const trackEvent = (action: string, category: string, label?: string, value?: number) => {
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', action, {
      event_category: category,
      event_label: label,
      value: value,
    })
  }
}

// Campaign-specific tracking
export const trackCampaignEvent = (eventName: string, campaignId: string, metadata?: any) => {
  trackEvent(eventName, 'campaign', campaignId, metadata?.value)
  
  // Custom campaign events
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', 'campaign_action', {
      custom_map: { custom_parameter_1: 'campaign_id' },
      campaign_id: campaignId,
      action_type: eventName,
      ...metadata
    })
  }
}

// Email tracking events
export const trackEmailEvent = (eventName: string, emailId: string, metadata?: any) => {
  trackEvent(eventName, 'email', emailId, metadata?.value)
}

// Page view tracking
export const trackPageView = (url: string, title?: string) => {
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('config', GA_MEASUREMENT_ID!, {
      page_location: url,
      page_title: title,
    })
  }
}

declare global {
  interface Window {
    gtag: (command: string, targetId: string, config?: any) => void
  }
}

export default function GoogleAnalytics() {
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    if (GA_MEASUREMENT_ID) {
      const url = pathname + searchParams.toString()
      trackPageView(url)
    }
  }, [pathname, searchParams])

  if (!GA_MEASUREMENT_ID) {
    return null
  }

  return (
    <>
      <Script
        strategy="afterInteractive"
        src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
      />
      <Script
        id="google-analytics"
        strategy="afterInteractive"
        dangerouslySetInnerHTML={{
          __html: `
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', '${GA_MEASUREMENT_ID}', {
              page_location: window.location.href,
              page_title: document.title,
            });
          `,
        }}
      />
    </>
  )
}
````

````typescript
// app/layout.tsx
import type { Metadata } from "next";
import { Raleway } from "next/font/google";
import "./globals.css";
import GoogleAnalytics from "@/components/analytics/GoogleAnalytics";

const raleway = Raleway({
  variable: "--font-raleway",
  subsets: ["latin"],
  weight: ["300", "400", "500", "600", "700", "800"], 
});

export const metadata: Metadata = {
  title: "Leadflow - B2B Cold Email Automation Platform",
  description: "LeadFlow is a B2B SaaS platform for automated, high-conversion cold email campaigns. Find, contact, and convert leads at scale with minimal manual effort.",
};
 
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <GoogleAnalytics />
      </head>
      <body
        className={`${raleway.variable} antialiased font-sans`}
      >
        {children} 
      </body>
    </html>
  );
}
````

## **Step 2: Database Schema Updates**

````sql
-- supabase/migrations/20240101000001_inbox_system.sql
-- Unified Inbox System Tables

-- Email messages/replies table
CREATE TABLE IF NOT EXISTS inbox_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
  contact_id UUID REFERENCES contacts(id) ON DELETE CASCADE,
  
  -- Message details
  message_id TEXT, -- External email provider message ID
  thread_id TEXT, -- Email thread identifier
  subject TEXT NOT NULL,
  content TEXT NOT NULL,
  html_content TEXT,
  
  -- Message metadata
  from_email TEXT NOT NULL,
  from_name TEXT,
  to_email TEXT NOT NULL,
  to_name TEXT,
  
  -- Tracking
  direction TEXT NOT NULL CHECK (direction IN ('inbound', 'outbound')),
  message_type TEXT DEFAULT 'reply' CHECK (message_type IN ('reply', 'forward', 'new')),
  
  -- AI Classification (for Milestone 2)
  classification TEXT,
  sentiment_score FLOAT,
  confidence_score FLOAT,
  tags TEXT[],
  
  -- Status
  is_read BOOLEAN DEFAULT FALSE,
  is_archived BOOLEAN DEFAULT FALSE,
  is_starred BOOLEAN DEFAULT FALSE,
  
  -- Timestamps
  received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email threads for conversation grouping
CREATE TABLE IF NOT EXISTS email_threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
  contact_id UUID REFERENCES contacts(id) ON DELETE CASCADE,
  
  thread_id TEXT NOT NULL, -- External thread identifier
  subject TEXT NOT NULL,
  
  -- Thread stats
  message_count INTEGER DEFAULT 0,
  last_message_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_message_from TEXT,
  
  -- Status
  is_active BOOLEAN DEFAULT TRUE,
  is_archived BOOLEAN DEFAULT FALSE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(organization_id, thread_id)
);

-- Reply detection patterns
CREATE TABLE IF NOT EXISTS reply_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  
  pattern_type TEXT NOT NULL CHECK (pattern_type IN ('subject', 'header', 'content')),
  pattern_value TEXT NOT NULL,
  confidence_weight FLOAT DEFAULT 1.0,
  
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_inbox_messages_org_id ON inbox_messages(organization_id);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_campaign_id ON inbox_messages(campaign_id);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_contact_id ON inbox_messages(contact_id);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_thread_id ON inbox_messages(thread_id);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_received_at ON inbox_messages(received_at DESC);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_direction ON inbox_messages(direction);
CREATE INDEX IF NOT EXISTS idx_inbox_messages_is_read ON inbox_messages(is_read);

CREATE INDEX IF NOT EXISTS idx_email_threads_org_id ON email_threads(organization_id);
CREATE INDEX IF NOT EXISTS idx_email_threads_campaign_id ON email_threads(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_threads_contact_id ON email_threads(contact_id);
CREATE INDEX IF NOT EXISTS idx_email_threads_thread_id ON email_threads(thread_id);
CREATE INDEX IF NOT EXISTS idx_email_threads_last_message_at ON email_threads(last_message_at DESC);

-- RLS Policies
ALTER TABLE inbox_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE reply_patterns ENABLE ROW LEVEL SECURITY;

-- Inbox messages policies
CREATE POLICY "Users can view their organization's inbox messages" ON inbox_messages
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

CREATE POLICY "Users can insert inbox messages for their organization" ON inbox_messages
  FOR INSERT WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

CREATE POLICY "Users can update their organization's inbox messages" ON inbox_messages
  FOR UPDATE USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Email threads policies
CREATE POLICY "Users can view their organization's email threads" ON email_threads
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their organization's email threads" ON email_threads
  FOR ALL USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Reply patterns policies
CREATE POLICY "Users can manage their organization's reply patterns" ON reply_patterns
  FOR ALL USING (
    organization_id IN (
      SELECT organization_id FROM users WHERE id = auth.uid()
    )
  );

-- Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_inbox_messages_updated_at 
  BEFORE UPDATE ON inbox_messages 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_email_threads_updated_at 
  BEFORE UPDATE ON email_threads 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
````

## **Step 3: Reply Detection Service**

````typescript
// lib/reply-detection.ts
import { supabase } from '@/lib/supabase'

export interface InboxMessage {
  id: string
  organization_id: string
  campaign_id?: string
  contact_id?: string
  message_id?: string
  thread_id?: string
  subject: string
  content: string
  html_content?: string
  from_email: string
  from_name?: string
  to_email: string
  to_name?: string
  direction: 'inbound' | 'outbound'
  message_type: 'reply' | 'forward' | 'new'
  classification?: string
  sentiment_score?: number
  confidence_score?: number
  tags?: string[]
  is_read: boolean
  is_archived: boolean
  is_starred: boolean
  received_at: string
  created_at: string
  updated_at: string
}

export interface EmailThread {
  id: string
  organization_id: string
  campaign_id?: string
  contact_id?: string
  thread_id: string
  subject: string
  message_count: number
  last_message_at: string
  last_message_from?: string
  is_active: boolean
  is_archived: boolean
  created_at: string
  updated_at: string
}

export class ReplyDetectionService {
  
  // Detect if an email is a reply based on various patterns
  static async detectReply(emailData: {
    subject: string
    content: string
    headers?: Record<string, string>
    from_email: string
    to_email: string
    references?: string[]
    in_reply_to?: string
  }): Promise<{
    isReply: boolean
    confidence: number
    threadId?: string
    originalCampaignId?: string
    originalContactId?: string
    replyType: 'reply' | 'forward' | 'new'
  }> {
    
    let confidence = 0
    let isReply = false
    let threadId: string | undefined
    let originalCampaignId: string | undefined
    let originalContactId: string | undefined
    let replyType: 'reply' | 'forward' | 'new' = 'new'

    // 1. Check subject line patterns
    const subjectPatterns = [
      /^re:\s*/i,
      /^reply:\s*/i,
      /^fwd:\s*/i,
      /^forward:\s*/i
    ]

    for (const pattern of subjectPatterns) {
      if (pattern.test(emailData.subject)) {
        confidence += 0.4
        isReply = true
        if (pattern.source.includes('fwd') || pattern.source.includes('forward')) {
          replyType = 'forward'
        } else {
          replyType = 'reply'
        }
        break
      }
    }

    // 2. Check for email headers (References, In-Reply-To)
    if (emailData.headers?.['References'] || emailData.in_reply_to) {
      confidence += 0.5
      isReply = true
      replyType = 'reply'
    }

    // 3. Check content patterns
    const contentPatterns = [
      /^on\s+.+wrote:$/im,
      /^from:\s*.+$/im,
      /^sent:\s*.+$/im,
      />.*$/m, // Quoted text
      /-----original message-----/i
    ]

    for (const pattern of contentPatterns) {
      if (pattern.test(emailData.content)) {
        confidence += 0.2
        isReply = true
        if (replyType === 'new') replyType = 'reply'
        break
      }
    }

    // 4. Look for matching campaigns/contacts in our database
    try {
      // Try to find original campaign by matching sender/recipient
      const { data: campaigns } = await supabase
        .from('campaigns')
        .select(`
          id,
          campaign_contacts!inner (
            contact_id,
            contacts!inner (
              email
            )
          )
        `)
        .eq('campaign_contacts.contacts.email', emailData.from_email)
        .limit(1)

      if (campaigns && campaigns.length > 0) {
        confidence += 0.3
        isReply = true
        originalCampaignId = campaigns[0].id
        originalContactId = campaigns[0].campaign_contacts[0].contact_id
        if (replyType === 'new') replyType = 'reply'
      }

      // Try to find existing thread
      const cleanSubject = emailData.subject.replace(/^(re:|reply:|fwd:|forward:)\s*/i, '').trim()
      const { data: existingThread } = await supabase
        .from('email_threads')
        .select('*')
        .ilike('subject', `%${cleanSubject}%`)
        .eq('is_active', true)
        .limit(1)
        .single()

      if (existingThread) {
        confidence += 0.4
        isReply = true
        threadId = existingThread.thread_id
        originalCampaignId = originalCampaignId || existingThread.campaign_id
        originalContactId = originalContactId || existingThread.contact_id
        if (replyType === 'new') replyType = 'reply'
      }

    } catch (error) {
      console.error('Error looking up campaign/thread data:', error)
    }

    return {
      isReply: confidence > 0.3, // Threshold for considering it a reply
      confidence,
      threadId,
      originalCampaignId,
      originalContactId,
      replyType
    }
  }

  // Process incoming email and add to inbox
  static async processIncomingEmail(emailData: {
    message_id?: string
    subject: string
    content: string
    html_content?: string
    from_email: string
    from_name?: string
    to_email: string
    to_name?: string
    headers?: Record<string, string>
    received_at?: string
  }, organizationId: string): Promise<InboxMessage> {

    // Detect if this is a reply
    const replyDetection = await this.detectReply(emailData)
    
    // Generate thread ID if not exists
    let threadId = replyDetection.threadId
    if (!threadId) {
      threadId = `thread_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    }

    // Create or update email thread
    const cleanSubject = emailData.subject.replace(/^(re:|reply:|fwd:|forward:)\s*/i, '').trim()
    
    const { data: thread, error: threadError } = await supabase
      .from('email_threads')
      .upsert({
        organization_id: organizationId,
        campaign_id: replyDetection.originalCampaignId,
        contact_id: replyDetection.originalContactId,
        thread_id: threadId,
        subject: cleanSubject,
        last_message_at: emailData.received_at || new Date().toISOString(),
        last_message_from: emailData.from_email,
        is_active: true
      }, {
        onConflict: 'organization_id,thread_id'
      })
      .select()
      .single()

    if (threadError) {
      console.error('Error creating/updating thread:', threadError)
    }

    // Create inbox message
    const { data: message, error: messageError } = await supabase
      .from('inbox_messages')
      .insert({
        organization_id: organizationId,
        campaign_id: replyDetection.originalCampaignId,
        contact_id: replyDetection.originalContactId,
        message_id: emailData.message_id,
        thread_id: threadId,
        subject: emailData.subject,
        content: emailData.content,
        html_content: emailData.html_content,
        from_email: emailData.from_email,
        from_name: emailData.from_name,
        to_email: emailData.to_email,
        to_name: emailData.to_name,
        direction: 'inbound',
        message_type: replyDetection.replyType,
        confidence_score: replyDetection.confidence,
        received_at: emailData.received_at || new Date().toISOString(),
        is_read: false
      })
      .select()
      .single()

    if (messageError) {
      throw new Error(`Failed to create inbox message: ${messageError.message}`)
    }

    // Update thread message count
    if (thread) {
      await supabase.rpc('increment_thread_message_count', {
        thread_id: thread.id
      })
    }

    return message
  }

  // Mark messages as read
  static async markAsRead(messageIds: string[], organizationId: string): Promise<void> {
    const { error } = await supabase
      .from('inbox_messages')
      .update({ is_read: true })
      .in('id', messageIds)
      .eq('organization_id', organizationId)

    if (error) {
      throw new Error(`Failed to mark messages as read: ${error.message}`)
    }
  }

  // Archive messages
  static async archiveMessages(messageIds: string[], organizationId: string): Promise<void> {
    const { error } = await supabase
      .from('inbox_messages')
      .update({ is_archived: true })
      .in('id', messageIds)
      .eq('organization_id', organizationId)

    if (error) {
      throw new Error(`Failed to archive messages: ${error.message}`)
    }
  }

  // Get inbox messages with pagination
  static async getInboxMessages(
    organizationId: string,
    options: {
      page?: number
      limit?: number
      filter?: 'all' | 'unread' | 'starred' | 'archived'
      campaignId?: string
      contactId?: string
    } = {}
  ): Promise<{
    messages: InboxMessage[]
    total: number
    hasMore: boolean
  }> {
    
    const { page = 1, limit = 50, filter = 'all', campaignId, contactId } = options
    const offset = (page - 1) * limit

    let query = supabase
      .from('inbox_messages')
      .select(`
        *,
        campaigns:campaign_id(id, name),
        contacts:contact_id(id, email, first_name, last_name, company)
      `, { count: 'exact' })
      .eq('organization_id', organizationId)
      .order('received_at', { ascending: false })

    // Apply filters
    if (filter === 'unread') {
      query = query.eq('is_read', false)
    } else if (filter === 'starred') {
      query = query.eq('is_starred', true)
    } else if (filter === 'archived') {
      query = query.eq('is_archived', true)
    } else {
      query = query.eq('is_archived', false) // Exclude archived by default
    }

    if (campaignId) {
      query = query.eq('campaign_id', campaignId)
    }

    if (contactId) {
      query = query.eq('contact_id', contactId)
    }

    const { data, error, count } = await query
      .range(offset, offset + limit - 1)

    if (error) {
      throw new Error(`Failed to fetch inbox messages: ${error.message}`)
    }

    return {
      messages: data || [],
      total: count || 0,
      hasMore: (count || 0) > offset + limit
    }
  }

  // Get email threads
  static async getEmailThreads(
    organizationId: string,
    options: {
      page?: number
      limit?: number
      campaignId?: string
      contactId?: string
    } = {}
  ): Promise<{
    threads: (EmailThread & {
      messages?: InboxMessage[]
      latest_message?: InboxMessage
    })[]
    total: number
    hasMore: boolean
  }> {
    
    const { page = 1, limit = 20, campaignId, contactId } = options
    const offset = (page - 1) * limit

    let query = supabase
      .from('email_threads')
      .select(`
        *,
        campaigns:campaign_id(id, name),
        contacts:contact_id(id, email, first_name, last_name, company)
      `, { count: 'exact' })
      .eq('organization_id', organizationId)
      .eq('is_active', true)
      .order('last_message_at', { ascending: false })

    if (campaignId) {
      query = query.eq('campaign_id', campaignId)
    }

    if (contactId) {
      query = query.eq('contact_id', contactId)
    }

    const { data, error, count } = await query
      .range(offset, offset + limit - 1)

    if (error) {
      throw new Error(`Failed to fetch email threads: ${error.message}`)
    }

    // Get latest message for each thread
    const threadsWithMessages = await Promise.all(
      (data || []).map(async (thread) => {
        const { data: latestMessage } = await supabase
          .from('inbox_messages')
          .select('*')
          .eq('thread_id', thread.thread_id)
          .order('received_at', { ascending: false })
          .limit(1)
          .single()

        return {
          ...thread,
          latest_message: latestMessage
        }
      })
    )

    return {
      threads: threadsWithMessages,
      total: count || 0,
      hasMore: (count || 0) > offset + limit
    }
  }
}
````

## **Step 4: Unified Inbox Store**

````typescript
// store/useInboxStore.ts
import { create } from 'zustand'
import { ReplyDetectionService, InboxMessage, EmailThread } from '@/lib/reply-detection'

interface InboxState {
  messages: InboxMessage[]
  threads: EmailThread[]
  loading: boolean
  currentView: 'messages' | 'threads'
  filter: 'all' | 'unread' | 'starred' | 'archived'
  selectedMessages: string[]
  
  // Pagination
  currentPage: number
  hasMore: boolean
  total: number
  
  // Actions
  fetchMessages: (organizationId: string, options?: any) => Promise<void>
  fetchThreads: (organizationId: string, options?: any) => Promise<void>
  markAsRead: (messageIds: string[], organizationId: string) => Promise<void>
  archiveMessages: (messageIds: string[], organizationId: string) => Promise<void>
  setFilter: (filter: 'all' | 'unread' | 'starred' | 'archived') => void
  setCurrentView: (view: 'messages' | 'threads') => void
  toggleMessageSelection: (messageId: string) => void
  clearSelection: () => void
  selectAll: () => void
  
  // Real-time updates
  subscribeToRealtime: (organizationId: string) => void
  unsubscribeFromRealtime: () => void
}

let realtimeChannel: any = null

export const useInboxStore = create<InboxState>((set, get) => ({
  messages: [],
  threads: [],
  loading: false,
  currentView: 'messages',
  filter: 'all',
  selectedMessages: [],
  currentPage: 1,
  hasMore: false,
  total: 0,

  fetchMessages: async (organizationId: string, options = {}) => {
    try {
      set({ loading: true })
      
      const { filter, currentPage } = get()
      const result = await ReplyDetectionService.getInboxMessages(organizationId, {
        page: currentPage,
        limit: 50,
        filter,
        ...options
      })
      
      set({
        messages: currentPage === 1 ? result.messages : [...get().messages, ...result.messages],
        total: result.total,
        hasMore: result.hasMore,
        loading: false
      })
      
    } catch (error) {
      console.error('Failed to fetch messages:', error)
      set({ loading: false })
    }
  },

  fetchThreads: async (organizationId: string, options = {}) => {
    try {
      set({ loading: true })
      
      const { currentPage } = get()
      const result = await ReplyDetectionService.getEmailThreads(organizationId, {
        page: currentPage,
        limit: 20,
        ...options
      })
      
      set({
        threads: currentPage === 1 ? result.threads : [...get().threads, ...result.threads],
        total: result.total,
        hasMore: result.hasMore,
        loading: false
      })
      
    } catch (error) {
      console.error('Failed to fetch threads:', error)
      set({ loading: false })
    }
  },

  markAsRead: async (messageIds: string[], organizationId: string) => {
    try {
      await ReplyDetectionService.markAsRead(messageIds, organizationId)
      
      // Update local state
      set(state => ({
        messages: state.messages.map(msg => 
          messageIds.includes(msg.id) ? { ...msg, is_read: true } : msg
        )
      }))
      
    } catch (error) {
      console.error('Failed to mark as read:', error)
    }
  },

  archiveMessages: async (messageIds: string[], organizationId: string) => {
    try {
      await ReplyDetectionService.archiveMessages(messageIds, organizationId)
      
      // Remove from current view if not showing archived
      const { filter } = get()
      if (filter !== 'archived') {
        set(state => ({
          messages: state.messages.filter(msg => !messageIds.includes(msg.id))
        }))
      }
      
    } catch (error) {
      console.error('Failed to archive messages:', error)
    }
  },

  setFilter: (filter) => {
    set({ filter, currentPage: 1, messages: [], threads: [] })
  },

  setCurrentView: (view) => {
    set({ currentView: view, currentPage: 1, messages: [], threads: [] })
  },

  toggleMessageSelection: (messageId) => {
    set(state => ({
      selectedMessages: state.selectedMessages.includes(messageId)
        ? state.selectedMessages.filter(id => id !== messageId)
        : [...state.selectedMessages, messageId]
    }))
  },

  clearSelection: () => {
    set({ selectedMessages: [] })
  },

  selectAll: () => {
    const { messages } = get()
    set({ selectedMessages: messages.map(msg => msg.id) })
  },

  subscribeToRealtime: (organizationId: string) => {
    // Implementation will be added with Supabase realtime
    console.log('Subscribing to inbox realtime updates for org:', organizationId)
  },

  unsubscribeFromRealtime: () => {
    if (realtimeChannel) {
      console.log('Unsubscribing from inbox realtime updates')
      realtimeChannel = null
    }
  }
}))
````

This completes the foundation for Milestone 1. Next, I'll create the actual Unified Inbox UI components. Should I continue with the inbox interface components?