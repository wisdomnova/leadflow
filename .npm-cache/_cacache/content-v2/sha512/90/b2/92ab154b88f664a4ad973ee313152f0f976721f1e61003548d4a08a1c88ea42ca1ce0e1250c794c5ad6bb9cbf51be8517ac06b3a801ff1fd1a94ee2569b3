{"_id":"@zone-eu/mailsplit","_rev":"4-c18fa79cbfe4df3ca76371173da173c5","name":"@zone-eu/mailsplit","dist-tags":{"latest":"5.4.8"},"versions":{"5.4.6":{"name":"@zone-eu/mailsplit","version":"5.4.6","author":{"name":"Andris Reinman"},"license":"(MIT OR EUPL-1.1+)","_id":"@zone-eu/mailsplit@5.4.6","maintainers":[{"name":"zone-main","email":"nikolai@zone.ee"}],"homepage":"https://github.com/zone-eu/mailsplit#readme","bugs":{"url":"https://github.com/zone-eu/mailsplit/issues"},"dist":{"shasum":"083b19898e8389ce1a5af797b012ede2f18d59f2","tarball":"https://registry.npmjs.org/@zone-eu/mailsplit/-/mailsplit-5.4.6.tgz","fileCount":13,"integrity":"sha512-wi+va5qgsDQe+64Mpp6t0obbO0Dm5zcACCxM/bVh1DjfZsu0CI1YsEE6GZJYmHKLZom1JmSh8Ehvc3LA3DeJZg==","signatures":[{"sig":"MEQCIGlSi6XqpTgMVf/plmmFB/CVMGeU5ShzYkG8zqUTaHdvAiBKqJc7YZtDP8dbkW7121SJxWLbE7NS0cWx2s7ifn3wJQ==","keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U"}],"unpackedSize":71248},"main":"index.js","gitHead":"6e3a5a39fae1758aacce450782acd29674f8b4af","scripts":{"test":"grunt","update":"rm -rf node_modules package-lock.json && ncu -u && npm install"},"_npmUser":{"name":"zone-main","email":"nikolai@zone.ee"},"repository":{"url":"git+https://github.com/zone-eu/mailsplit.git","type":"git"},"_npmVersion":"11.6.0","description":"Split email messages into an object stream","directories":{"test":"test"},"_nodeVersion":"24.8.0","dependencies":{"libqp":"2.1.1","libmime":"5.3.7","libbase64":"1.3.0"},"_hasShrinkwrap":false,"devDependencies":{"grunt":"1.6.1","eslint":"8.29.0","grunt-cli":"1.5.0","grunt-eslint":"24.0.1","random-message":"1.1.0","eslint-config-prettier":"9.1.0","grunt-contrib-nodeunit":"5.0.0","eslint-config-nodemailer":"1.2.0"},"_npmOperationalInternal":{"tmp":"tmp/mailsplit_5.4.6_1760598305966_0.3572209203383545","host":"s3://npm-registry-packages-npm-production"}},"5.4.7":{"name":"@zone-eu/mailsplit","version":"5.4.7","author":{"name":"Andris Reinman"},"license":"(MIT OR EUPL-1.1+)","_id":"@zone-eu/mailsplit@5.4.7","maintainers":[{"name":"zone-main","email":"nikolai@zone.ee"}],"homepage":"https://github.com/zone-eu/mailsplit#readme","bugs":{"url":"https://github.com/zone-eu/mailsplit/issues"},"dist":{"shasum":"ad86fe08222883418f33cf02d57025de02d2eb38","tarball":"https://registry.npmjs.org/@zone-eu/mailsplit/-/mailsplit-5.4.7.tgz","fileCount":13,"integrity":"sha512-jApX86aDgolMz08pP20/J2zcns02NSK3zSiYouf01QQg4250L+GUAWSWicmS7eRvs+Z7wP7QfXrnkaTBGrIpwQ==","signatures":[{"sig":"MEYCIQD1AQflO/zsUNG5qmeg1flP0zZjYoTGBmICUN7v+Vfc5wIhAP54AvmvjFqvlfUerP7B5nZy28OszETFfVUn5jsBfPiC","keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@zone-eu%2fmailsplit@5.4.7","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":71248},"main":"index.js","gitHead":"374f33c5a058950084d2bf64735c8e12006c4cc1","scripts":{"test":"grunt","update":"rm -rf node_modules package-lock.json && ncu -u && npm install"},"_npmUser":{"name":"GitHub Actions","email":"npm-oidc-no-reply@github.com","trustedPublisher":{"id":"github","oidcConfigId":"oidc:e901293d-a7ec-44a5-99bb-c632712c9ed6"}},"repository":{"url":"git+https://github.com/zone-eu/mailsplit.git","type":"git"},"_npmVersion":"11.6.1","description":"Split email messages into an object stream","directories":{"test":"test"},"_nodeVersion":"24.10.0","dependencies":{"libqp":"2.1.1","libmime":"5.3.7","libbase64":"1.3.0"},"_hasShrinkwrap":false,"devDependencies":{"grunt":"1.6.1","eslint":"8.29.0","grunt-cli":"1.5.0","grunt-eslint":"24.0.1","random-message":"1.1.0","eslint-config-prettier":"9.1.0","grunt-contrib-nodeunit":"5.0.0","eslint-config-nodemailer":"1.2.0"},"_npmOperationalInternal":{"tmp":"tmp/mailsplit_5.4.7_1760598907500_0.6108579572378454","host":"s3://npm-registry-packages-npm-production"}},"5.4.8":{"name":"@zone-eu/mailsplit","version":"5.4.8","description":"Split email messages into an object stream","main":"index.js","directories":{"test":"test"},"scripts":{"test":"grunt","update":"rm -rf node_modules package-lock.json && ncu -u && npm install"},"author":{"name":"Andris Reinman"},"license":"(MIT OR EUPL-1.1+)","dependencies":{"libbase64":"1.3.0","libmime":"5.3.7","libqp":"2.1.1"},"devDependencies":{"eslint":"8.29.0","eslint-config-nodemailer":"1.2.0","eslint-config-prettier":"9.1.0","grunt":"1.6.1","grunt-cli":"1.5.0","grunt-contrib-nodeunit":"5.0.0","grunt-eslint":"24.0.1","random-message":"1.1.0"},"repository":{"type":"git","url":"git+https://github.com/zone-eu/mailsplit.git"},"gitHead":"b4490c43b74683fe56950a221f22971f8b657556","_id":"@zone-eu/mailsplit@5.4.8","bugs":{"url":"https://github.com/zone-eu/mailsplit/issues"},"homepage":"https://github.com/zone-eu/mailsplit#readme","_nodeVersion":"24.11.1","_npmVersion":"11.6.2","dist":{"integrity":"sha512-eEyACj4JZ7sjzRvy26QhLgKEMWwQbsw1+QZnlLX+/gihcNH07lVPOcnwf5U6UAL7gkc//J3jVd76o/WS+taUiA==","shasum":"fc3e433f5b8132103324d7728f3fa00426aea822","tarball":"https://registry.npmjs.org/@zone-eu/mailsplit/-/mailsplit-5.4.8.tgz","fileCount":13,"unpackedSize":71248,"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/@zone-eu%2fmailsplit@5.4.8","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"signatures":[{"keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U","sig":"MEUCIQDyjxu7K2H1dI5Sd150gBGT/HZaIBV7brMpolWNxds10QIgRS9tgOD1CJO8gTkWBO2EmfkbAvyOsf/LifOZ9cD39HQ="}]},"_npmUser":{"name":"GitHub Actions","email":"npm-oidc-no-reply@github.com","trustedPublisher":{"id":"github","oidcConfigId":"oidc:e901293d-a7ec-44a5-99bb-c632712c9ed6"}},"maintainers":[{"name":"zone-main","email":"nikolai@zone.ee"},{"name":"andris","email":"andris@kreata.ee"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/mailsplit_5.4.8_1765215745749_0.549473181365919"},"_hasShrinkwrap":false}},"time":{"created":"2025-10-16T07:05:05.879Z","modified":"2025-12-08T17:42:26.264Z","5.4.6":"2025-10-16T07:05:06.142Z","5.4.7":"2025-10-16T07:15:07.702Z","5.4.8":"2025-12-08T17:42:25.889Z"},"bugs":{"url":"https://github.com/zone-eu/mailsplit/issues"},"author":{"name":"Andris Reinman"},"license":"(MIT OR EUPL-1.1+)","homepage":"https://github.com/zone-eu/mailsplit#readme","repository":{"type":"git","url":"git+https://github.com/zone-eu/mailsplit.git"},"description":"Split email messages into an object stream","maintainers":[{"name":"zone-main","email":"nikolai@zone.ee"},{"name":"andris","email":"andris@kreata.ee"}],"readme":"# mailsplit\n\nSplit an email message stream into structured parts and join these parts back into an email message stream. If you do not modify the parsed data then the rebuilt message should be an exact copy of the original.\n\nThis is useful if you want to modify some specific parts of an email, for example to add tracking images or unsubscribe links to the HTML part of the message without changing any other parts of the email.\n\nSupports both &lt;CR&gt;&lt;LF&gt; and &lt;LF&gt; (or mixed) line endings. Embedded rfc822 messages are also parsed, in this case you would get two sequential 'node' objects with no 'data' or 'body' in between (first 'node' is for the container node and second for the root node of the embedded message).\n\nIn general this module is a primitive for building e-mail parsers/handlers like [mailparser](https://www.npmjs.com/package/mailparser). Alternatively you could use it to parse other MIME-like structures, for example _mbox_ files or multipart/form-data uploads.\n\nSee [rewrite-html.js](examples/rewrite-html.js) for an usage example where HTML content is modified on the fly (example script adds a link to every _text/html_ node)\n\n## Usage\n\n### Install\n\nInstall from [npm](https://www.npmjs.com/package/mailsplit)\n\n    npm install mailsplit --save\n\n### Split message stream\n\n`Splitter` is a transformable stream where input is a byte stream and output is an object stream.\n\n```javascript\nlet Splitter = require('mailsplit').Splitter;\nlet splitter = new Splitter(options);\n```\n\nWhere\n\n-   **options** is an optional options object\n    -   **options.ignoreEmbedded** (boolean, defaults to false) if true then treat message/rfc822 node as normal leaf node and do not try to parse it\n    -   **options.maxHeadSize** (number, defaults to Infinity) limits message header size in bytes\n\n#### Events\n\n**'data'** event emits the next parsed object from the message stream.\n\n#### Data objects\n\n-   **type**\n    -   `'node'` means that we reached the next mime node and the previous one is completely processed\n    -   `'data'` provides us multipart body parts, including boundaries. This data is not directly related to any specific multipart node, basically it includes everything between the end of one normal node and the header of next node\n    -   `'body'` provides us next chunk for the last seen `'node'` element\n-   **value** is a buffer value for `'body'` and `'data'` parts\n-   **getDecoder()** is a function that returns a stream object you can use to decode node contents. Write data from 'body' to decoder and read decoded Buffer value out from it\n-   **getEncoder()** is a function that returns a stream object you can use to encode node contents. Write buffer data to encoder and read encoded object value out that you can pass to a Joiner\n\nElement with type `'node'` has a bunch of header related methods and properties, see [below](#manipulating-headers).\n\n**Example**\n\n```javascript\nlet Splitter = require('mailsplit').Splitter;\nlet splitter = new Splitter();\n// handle parsed data\nsplitter.on('data', data => {\n    switch (data.type) {\n        case 'node':\n            // node header block\n            process.stdout.write(data.getHeaders());\n            break;\n        case 'data':\n            // multipart message structure\n            // this is not related to any specific 'node' block as it includes\n            // everything between the end of some node body and between the next header\n            process.stdout.write(data.value);\n            break;\n        case 'body':\n            // Leaf element body. Includes the body for the last 'node' block. You might\n            // have several 'body' calls for a single 'node' block\n            process.stdout.write(data.value);\n            break;\n    }\n});\n// send data to the parser\nsomeMessagStream.pipe(splitter);\n```\n\n### Manipulating headers\n\nIf the data object has `type='node'` then you can modify headers for that node (headers can be modified until the data object is passed over to a `Joiner`)\n\n-   **node.getHeaders()** returns a Buffer value with generated headers. If you have not modified the headers object in any way then you should get the exact copy of the original. In case you have done something (for example removed a key, or added a new header key), then all linebreaks are forced to &lt;CR&gt;&lt;LF&gt; even if the original headers used just &lt;LF&gt;\n-   **node.setContentType(contentType)** sets or updates mime type for the node\n-   **node.setCharset(charset)** sets or updates character set in the Content-Type header\n-   **node.setFilename(filename)** sets or updates filename in the Content-Disposition header (unicode allowed)\n\nYou can manipulate specific header keys as well using the `headers` object\n\n-   **node.headers.get(key)** returns an array of strings with all header rows for the selected key (these are full header lines, so key name is part of the row string, eg `[\"Subject: This is subject line\"]`)\n-   **node.headers.getFirst(key)** returns string value of the specified header key (eg `\"This is subject line\"`)\n-   **node.headers.hasHeader(key)** returns boolean value if the specified header key exists\n-   **node.headers.add(key, value [,index])** adds a new header value to the specified index or to the top of the header block if index is not specified\n-   **node.headers.update(key, value, [,relativeKeyIndex])** replaces a header value to the specified relative key index (note that relative key index means relative to the same header key, eg if multiple exist and you specify `1` as the value, then it will update the second) or if no relative key index is specified, then it will remove all header value matches found for the key and append one at the last matching key index found with the specified value. If a relative key index is specified and it does not exist then it will be replaced (eg if there are two headers of `X-Foo-Bar` and you pass `2`, meaning it will update the third, no updates will be made since the third did not exist)\n-   **node.headers.remove(key)** remove header value\n-   **node.headers.mbox** If this is a MBOX formatted message then this value holds the prefix line (eg. \"From MAILER-DAEMON Fri Jul 8 12:08:34 2011\")\n-   **node.headers.mbox** If this is a POST form-data then this value holds the HTTP prefix line (eg. \"POST /upload.php HTTP/1.1\")\n\nAdditionally you can check the details of the node with the following properties automatically parsed from the headers:\n\n-   **node.root** if true then it means this is the message root, so this node should contain Subject, From, To etc. headers\n-   **node.contentType** returns the mime type of the node (eg. 'text/html')\n-   **node.disposition** either `'attachment'`, `'inline'` or `false` if not set\n-   **node.charset** returns the charset of the node as defined in 'Content-Type' header (eg. 'UTF-8') or false if not defined\n-   **node.encoding** returns the Transfer-Encoding value (eg. 'base64' or 'quoted-printable') or false if not defined\n-   **node.multipart** if has value, then this is a multipart node (does not have 'body' parts)\n-   **node.filename** is set if the headers contain a filename value. This is decoded to unicode, so it is a normal string or false if not found\n\n### Join parsed message stream\n\n`Joiner` is a transformable stream where input is the object stream form `Splitter` and output is a byte stream.\n\n```javascript\nlet Splitter = require('mailsplit').Splitter;\nlet Joiner = require('mailsplit').Joiner;\nlet splitter = new Splitter();\nlet joiner = new Joiner();\n// pipe a message source to splitter, then joiner and finally to stdout\nsomeMessagStream\n    .pipe(splitter)\n    .pipe(joiner)\n    .pipe(process.stdout);\n```\n\n### Rewrite specific nodes\n\n`Rewriter` is a simple helper class to modify nodes that match a filter function. You can pipe a Splitter stream directly into a Rewriter and pipe Rewriter output to a Joiner.\n\nRewriter takes the following argument:\n\n-   **filterFunc** gets the current node as argument and starts processing it if `filterFunc` returns true\n\nOnce Rewriter finds a matching node, it emits the following event:\n\n-   _'node'_ with an object argument `data`\n    -   `data.node` includes the current node with headers\n    -   `data.decoder` is the decoder stream that you can read data from\n    -   `data.encoder` is the encoder stream that you can write data to. Whatever you write into that stream will be encoded properly and inserted as the content of the current node\n\n```javascript\nlet Splitter = require('mailsplit').Splitter;\nlet Joiner = require('mailsplit').Joiner;\nlet Rewriter = require('mailsplit').Rewriter;\nlet splitter = new Splitter();\nlet joiner = new Joiner();\nlet rewriter = new Rewriter(node => node.contentType === 'text/html');\nrewriter.on('node', data => {\n    // manage headers with node.headers\n    node.headers.add('X-Processed-Time', new Date.toISOString());\n    // do nothing, just reencode existing data\n    data.decoder.pipe(data.encoder);\n});\n// pipe a message source to splitter, then rewriter, then joiner and finally to stdout\nsomeMessagStream\n    .pipe(splitter)\n    .pipe(rewriter)\n    .pipe(joiner)\n    .pipe(process.stdout);\n```\n\n### Stream specific nodes\n\n`Streamer` is a simple helper class to stream nodes that match a filter function. You can pipe a Splitter stream directly into a Streamer and pipe Streamer output to a Joiner.\n\nStreamer takes the following argument:\n\n-   **filterFunc** gets the current node as argument and starts processing it if `filterFunc` returns true\n\nOnce Streamer finds a matching node, it emits the following event:\n\n-   _'node'_ with an object argument `data`\n    -   `data.node` includes the current node with headers (informational only, you can't modify it)\n    -   `data.decoder` is the decoder stream that you can read data from\n    -   `data.done` is a function you must call once you have processed the stream\n\n```javascript\nlet Splitter = require('mailsplit').Splitter;\nlet Joiner = require('mailsplit').Joiner;\nlet Streamer = require('mailsplit').Streamer;\nlet fs = require('fs');\nlet splitter = new Splitter();\nlet joiner = new Joiner();\nlet streamer = new Streamer(node => node.contentType === 'image/jpeg');\nstreamer.on('node', data => {\n    // write to file\n    data.decoder.pipe(fs.createWriteStream(data.node.filename || 'image.jpg'));\n    data.done();\n});\n// pipe a message source to splitter, then streamer, then joiner and finally to stdout\nsomeMessagStream\n    .pipe(splitter)\n    .pipe(streamer)\n    .pipe(joiner)\n    .pipe(process.stdout);\n```\n\n### Benchmark\n\nParsing and re-building messages is not fast but it isn't slow either. On my Macbook Pro I got around 22 MB/second (single process, single parsing queue) when parsing random messages from my own email archive. Time spent includes file calls to find and load random messages from disk.\n\n```\nStreaming 20000 random messages through a plain PassThrough\nDone. 20000 messages [1244 MB] processed in 10.095 s. with average of 1981 messages/sec [123 MB/s]\nStreaming 20000 random messages through Splitter and Joiner\nDone. 20000 messages [1244 MB] processed in 55.882 s. with average of 358 messages/sec [22 MB/s]\n```\n\n## License\n\nDual licensed under **MIT** or **EUPLv1.1+**\n\n> `mailsplit` is part of the Zone Mail Suite (ZMS). Suite of programs and modules for an efficient, fast and modern email server.","readmeFilename":"README.md"}